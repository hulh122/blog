---
title: Javascript 中的安全整数
permalink: /tech/:year/:month/:day/:slug.html
date: 2021-10-22
desc: 在 Server 端面向前端的接口中，一般 id 的类型都会用 String 来替代 Number，原因是 Javacript 中 Number 最多能精确表示 2^53 - 1，而超长的 id 可能会导致重大问题。那么不禁想问，为什么一定是这个值呢？
imgName: 1
---

<Title />

### 简介
在 Server 端面向前端的接口中，一般 id 的类型都会用 `String` 来替代 `Number`，原因是 Javacript 中 `Number` 最多能精确表示 2^53 - 1，而超长的 id 可能会导致重大问题。  
那么不禁想问，为啥一定是这个值呢？

### 什么是安全整数？
Javacript 中的数字类型只有一种：`Number` 类型（这句话可能不一定准确，后来添加了 BigInt），也就是 `64-bit` 的浮点数。其在（-2^53, 2^53）范围内，双精度数表示和整数是一对一的。这个范围内的整数叫做安全整数。

### 为什么是 2^53 - 1
根据 `IEEEE754` 规定，双精度浮点数的有效数字是 52 位。其第一位是符号位[sign]，接着是 11 位的指数位[exponent]，剩下的是 52 位的有效数字位[significand]。  
计算机内部在保存有效数字时，默认第一位总是 1，所以舍去，只保留后面的部分。比如保存 1.01，只存 01，等读取的时候再把第一位 1 加上去。所以 52 位有效数字实际上可以存储 53 位。  
即 `1.1111..1111(小数点后 52 个 1)`，用等比数列相加为 `2^53 - 1`

### 为什么指数位 Exponent 是 11 位
为了保证当 sign 为 0，且 E 的首位也为 0 不被程序当做无效片段舍弃，`IEEE754` 默认 E 的首位为 1，这就是使得 E 转化为十进制时需要减去 1023。  
例：如 E = 10000000001，其十进制数字位 1025，实际代表的指数为 2^(1025 - 1023) = 2^2，即十进制下的指数位为 2。

### 当首位为 1 的时候，怎么表示 0、1、2、3
用指数位和有效数字来组织，下面的指数位均为十进制减掉 1023 后的结果：  
0：指数位 0，有效数字 0  
1：指数位 0，有效数字 1.0  
2：指数位 1，有效数字 1.0  
3：指数位 1，有效数字 1.1

### 存储方式
`2^53 - 1` 存储：符号位 0，指数为 52，尾数：1.1111...1111(小数点后一共 52 个 1)。  
`2^53 - 2` 储存：符号位 0，指数为 52，尾数：1.1111...1110(小数点后一共 51 个 1)。  
以此类推，可以推到 0。可以看到这个过程中，每向下减一，通过修改尾数和指数（有时指数不变），每一个整数都可以由一个浮点数‘模拟’。

### 一些说明
- 为什么 `2^53` 不能算是一个安全的整数？  
因为 `2^53` 的指数位已经达到了 53，损失了一位精度，尽管它确实是`一一对应`的。
```js
Math.pow(2,53) === Math.pow(2,53) + 1 //true
```

- 在 Javascript 中，一些只处理 32 位或者 16 位的运算符（e.g. & | ^ ~ >> >>> <<）在处理之前要把数值全部转化为 32 位（有/无符号）或 16 位，处理完成后再转换 64 位浮点数返回。

### 一些扩展
- [leetcode 大数相加](https://leetcode-cn.com/problems/add-strings/)
- [BigInt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt) - 表达比 `2^53 - 1` 更大的数
- [IEEE-754-calculator](http://weitz.de/ieee/)


