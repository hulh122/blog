---
title: 聊聊变量提升
permalink: /tech/:year/:month/:day/:slug.html 
date: 2021-12-13
desc: 当我们聊到变量提升，你听过的最多的是什么？var 的变量都是会提升的，函数都会提升，let 不会提升？真的是这样吗？
imgName: 13
---

<Title />

### 简介
当我们聊到变量提升，你听过的最多的是什么？`var` 的变量都是会提升的，`函数` 都会提升，`let` 不会提升？真的是这样吗？

### 我们怎么理解变量提升
```js
console.log(a); // undefind
var a = 1;
```
👆 的例子应该大家在学习变量提升的时候都看过，当时我们的理解是，被 var 所申明的变量都会提升到最顶部，这样我们的变量就可以在申明前使用了。

但这样理解的方式是错误的，JS 引擎在解释在段代码的时候其实不是用了变量提升这个名词，而是先申明变量，再初始化它的值。
- 解释器找到这个解释的作用域。
- 申明作用域中的变量，并将他们初始化为 undefind。（申明 / 初始化）。
- 执行语句，第一句 a 为 undefind，第二句 a 被赋值为 1。

再来看看函数的变量提升
```js
fn();

function fn() {
    console.log('fn');
}
```
函数的执行在申明之前，这在解释器中是怎么做到的？
- 解释器找到这个解释的作用域。
- 解释器找到了 function 这个关键字，将 fn 申明出来并对其赋值。（申明 / 赋值）。
- 执行语句，第一句执行 fn 函数。

学会以上两个方式，再看看下面这个例子，是否是清晰的？
```js
fn(); // error

var fn = function () {
    console.log('fn');
}
```

### let 是真的不会进行变量提升吗？
我在学习 `let` 的时候，知道它有三大特性：
- let 申明的变量的作用域是块级的。
- let 不能重复声明已存在的变量。
- let 有暂时性死区，不会被提升。

但事实是 `let` 会进行提升，但不会被初始化，由于其暂时性死区的特性（未初始化的值无法使用），所以引擎会报错。
```js
console.log(a); // error
let a = 1;
```
解释器在执行上面的语句是这么做的：
- 解释器找到这个解释的作用域。
- 解释器找到了 let 这个关键字，并申明了 a 这个变量，但没有**初始化**。
- 执行语句，第一句是一个申明但没有初始化值的变量，触发暂时性死区，报错。

### 一些拓展
- [let 的深入理解](https://www.jianshu.com/p/0f49c88cf169)
